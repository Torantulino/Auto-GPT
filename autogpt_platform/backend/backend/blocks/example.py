import logging
from typing import Any, Literal

from pydantic import SecretStr

from backend.data.block import (
    Block,
    BlockCategory,
    BlockManualWebhookConfig,
    BlockOutput,
    BlockSchema,
    BlockType,
)
from backend.data.model import (
    APIKeyCredentials,
    ContributorDetails,
    CredentialsField,
    CredentialsMetaInput,
    SchemaField,
)
from backend.integrations.providers import ProviderName
from backend.integrations.webhooks.example import ExampleWebhookType

logger = logging.getLogger(__name__)
ExampleCredentials = CredentialsMetaInput[
    ProviderName.EXAMPLE_PROVIDER, Literal["api_key"]
]

TEST_CREDENTIALS = APIKeyCredentials(
    id="9191c4f0-498f-4235-a79c-59c0e37454d4",
    provider="example-provider",
    api_key=SecretStr("mock-example-api-key"),
    title="Mock Example API key",
    expires_at=None,
)
TEST_CREDENTIALS_INPUT = {
    "provider": TEST_CREDENTIALS.provider,
    "id": TEST_CREDENTIALS.id,
    "type": TEST_CREDENTIALS.type,
    "title": TEST_CREDENTIALS.title,
}


class ExampleBlock(Block):

    class ExampleBlockInput(BlockSchema):
        name: str = SchemaField(description="The name of the example block")
        greeting: str = SchemaField(description="The greeting to display")
        is_funny: bool = SchemaField(description="Whether the block is funny")
        # Only if the block needs credentials
        credentials: ExampleCredentials = CredentialsField()

    class ExampleBlockOutput(BlockSchema):
        response: dict[str, Any] = SchemaField(
            description="The response object generated by the example block."
        )
        error: str = SchemaField(description="The error from the example block")

    def __init__(self):
        super().__init__(
            # The unique identifier for the block, this value will be persisted in the DB.
            # It should be unique and constant across the application run.
            # Use the UUID format for the ID.
            id="380694d5-3b2e-4130-bced-b43752b70de9",
            # The description of the block, explaining what the block does.
            description="The example block",
            # The list of contributors who contributed to the block.
            # Each contributor is represented by a ContributorDetails object.
            contributors=[ContributorDetails(name="Craig Swift")],
            # The set of categories that the block belongs to.
            # Each category is an instance of BlockCategory Enum.
            categories={BlockCategory.BASIC},
            # The schema, defined as a Pydantic model, for the input data.
            input_schema=self.ExampleBlockInput,
            # The schema, defined as a Pydantic model, for the output data.
            output_schema=self.ExampleBlockOutput,
            # The list or single sample input data for the block, for testing.
            # This is an instance of the Input schema with sample values.
            test_input=self.ExampleBlockInput(
                name="Craig", greeting="Hello", is_funny=True
            ).model_dump(),
            # The list or single expected output if the test_input is run.
            # Each output is a tuple of (output_name, output_data).
            test_output=[
                ("response", {"message": "Hello, world!"}),
            ],
            # Function names on the block implementation to mock on test run.
            # Each mock is a dictionary with function names as keys and mock implementations as values.
            test_mock={
                "my_function_that_can_be_mocked": lambda *args, **kwargs: "Hello, world!"
            },
            # The credentials required for testing the block.
            # This is an instance of APIKeyCredentials with sample values.
            test_credentials=TEST_CREDENTIALS,
            # The type of the block, which is an instance of BlockType Enum.
            block_type=BlockType.STANDARD,
            # The webhook configuration for the block, if any.
            # This can be an instance of BlockWebhookConfig or BlockManualWebhookConfig.
            webhook_config=None,
        )

    def my_function_that_can_be_mocked(self, input: str) -> str:
        logger.info("my_function_that_can_be_mocked called with input: %s", input)
        return "Hello, world!"

    def run(self, input_data: ExampleBlockInput, **kwargs) -> BlockOutput:
        try:
            message = self.my_function_that_can_be_mocked(input_data.greeting)
            yield "response", {"message": message}
        except Exception as e:
            logger.error("Error in run method: %s", e)
            yield "error", str(e)


class ExampleTriggerBlock(Block):
    """
    A trigger block that is activated by an external webhook event.

    Unlike standard blocks that are manually executed, trigger blocks are automatically
    activated when a webhook event is received from the specified provider.
    """

    class Input(BlockSchema):
        # The payload field is hidden because it's automatically populated by the webhook
        # system rather than being manually entered by the user
        payload: dict = SchemaField(hidden=True)

    class Output(BlockSchema):
        event_data: dict = SchemaField(
            description="The contents of the example webhook event."
        )

    def __init__(self):
        super().__init__(
            id="7c5933ce-d60c-42dd-9c4e-db82496474a3",
            description="This block will output the contents of an example webhook event.",
            categories={BlockCategory.BASIC},
            input_schema=ExampleTriggerBlock.Input,
            output_schema=ExampleTriggerBlock.Output,
            # The webhook_config is a key difference from standard blocks
            # It defines which external service can trigger this block and what type of events it responds to
            webhook_config=BlockManualWebhookConfig(
                provider="example_provider",  # The external service that will send webhook events
                webhook_type=ExampleWebhookType.EXAMPLE,  # The specific event type this block responds to
            ),
            # Test input for trigger blocks should mimic the payload structure that would be received from the webhook
            test_input=[
                {
                    "payload": {
                        "event_type": "example",
                        "data": "Sample webhook data",
                    }
                }
            ],
        )

    def run(self, input_data: Input, **kwargs) -> BlockOutput:
        # For trigger blocks, the run method is called automatically when a webhook event is received
        # The payload from the webhook is passed in as input_data.payload
        yield "event_data", input_data.payload
