import logging
from typing import Any

from backend.data.block import Block, BlockCategory, BlockOutput, BlockSchema, BlockType
from backend.data.model import (
    APIKeyCredentials,
    ContributorDetails,
    CredentialsField,
    SchemaField,
)

from ._api import ExampleClient
from ._auth import TEST_CREDENTIALS, TEST_CREDENTIALS_INPUT, ExampleCredentialsInput

logger = logging.getLogger(__name__)


class ExampleBlock(Block):

    class Input(BlockSchema):
        name: str = SchemaField(
            description="The name of the example block", placeholder="Enter a name"
        )
        greetings: list[str] = SchemaField(
            description="The greetings to display", default=["Hello", "Hi", "Hey"]
        )
        is_funny: bool = SchemaField(
            description="Whether the block is funny", placeholder="True", default=True
        )
        # Only if the block needs credentials
        credentials: ExampleCredentialsInput = CredentialsField(
            description="The credentials for the example block"
        )

    class Output(BlockSchema):
        response: dict[str, Any] = SchemaField(
            description="The response object generated by the example block."
        )
        all_responses: list[dict[str, Any]] = SchemaField(
            description="All the responses from the example block."
        )
        greeting_count: int = SchemaField(
            description="The number of greetings in the input."
        )
        error: str = SchemaField(description="The error from the example block")

    def __init__(self):
        super().__init__(
            # The unique identifier for the block, this value will be persisted in the DB.
            # It should be unique and constant across the application run.
            # Use the UUID format for the ID.
            id="380694d5-3b2e-4130-bced-b43752b70de9",
            # The description of the block, explaining what the block does.
            description="The example block",
            # The list of contributors who contributed to the block.
            # Each contributor is represented by a ContributorDetails object.
            contributors=[ContributorDetails(name="Craig Swift")],
            # The set of categories that the block belongs to.
            # Each category is an instance of BlockCategory Enum.
            categories={BlockCategory.BASIC},
            # The schema, defined as a Pydantic model, for the input data.
            input_schema=ExampleBlock.Input,
            # The schema, defined as a Pydantic model, for the output data.
            output_schema=ExampleBlock.Output,
            # The list or single sample input data for the block, for testing.
            # This is an instance of the Input schema with sample values.
            test_input={
                "name": "Craig",
                "greetings": ["Hello", "Hi", "Hey"],
                "is_funny": True,
                "credentials": TEST_CREDENTIALS_INPUT,
            },
            # The list or single expected output if the test_input is run.
            # Each output is a tuple of (output_name, output_data).
            test_output=[
                ("response", {"message": "Hello, world!"}),
                ("response", {"message": "Hello, world!"}),  # We mock the function
                ("response", {"message": "Hello, world!"}),  # We mock the function
                (
                    "all_responses",
                    [
                        {"message": "Hello, world!"},
                        {"message": "Hello, world!"},
                        {"message": "Hello, world!"},
                    ],
                ),
            ],
            # Function names on the block implementation to mock on test run.
            # Each mock is a dictionary with function names as keys and mock implementations as values.
            test_mock={
                "my_function_that_can_be_mocked": lambda *args, **kwargs: "Hello, world!"
            },
            # The credentials required for testing the block.
            # This is an instance of APIKeyCredentials with sample values.
            test_credentials=TEST_CREDENTIALS,
            # The type of the block, which is an instance of BlockType Enum.
            block_type=BlockType.STANDARD,
        )

    @staticmethod
    def my_static_method(input: str) -> str:
        logger.info("my_static_method called with input: %s", input)
        return f"Hello, {input}!"

    def my_function_that_can_be_mocked(
        self, input: str, credentials: APIKeyCredentials
    ) -> str:
        logger.info("my_function_that_can_be_mocked called with input: %s", input)

        # Use the ExampleClient from _api.py to make an API call
        client = ExampleClient(credentials=credentials)

        # Create a sample resource using the client
        resource_data = {"name": input, "type": "greeting"}
        response = client.create_resource(resource_data)
        return f"API response: {response.get('message', 'Hello, world!')}"

    def run(
        self, input_data: Input, *, credentials: APIKeyCredentials, **kwargs
    ) -> BlockOutput:
        """
        The run function implements the block's core logic. It processes the input_data
        and yields the block's output.

        In addition to credentials, the following parameters can be specified:
            graph_id: The ID of the graph containing this block.
            node_id: The ID of this block's node in the graph.
            graph_exec_id: The ID of the current graph execution.
            node_exec_id: The ID of the current node execution.
            user_id: The ID of the user executing the block.
        """
        rtn_all_responses: list[dict[str, Any]] = []
        # Here we deomonstrate best practice for blocks that need to yield multiple items.
        # We yield each item from the list to allow for operations on each element.
        # We also yield the complete list for situations when the full list is needed.
        for greeting in input_data.greetings:
            full_greeting = ExampleBlock.my_static_method(greeting)
            message = self.my_function_that_can_be_mocked(full_greeting, credentials)
            rtn_all_responses.append({"message": message})
            yield "response", {"message": message}
        yield "all_responses", rtn_all_responses
        yield "greeting_count", len(input_data.greetings)
